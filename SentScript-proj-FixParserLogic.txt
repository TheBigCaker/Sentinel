<#
Sentinel Patch Payload (Fix Parser Logic)
This script patches 'Sentinel.py' to fix the project ID parser. It updates the parser to correctly handle IDs like 'proj-b6cc'.
#>
--- 1. Configuration ---
$SentinelToolPath = "C:\Dev\sentinel\Sentinel.py" # Use absolute path for self-patching
$CommitMessage = "fix(sentinel): Fix parser logic to handle 'proj-XXXX' IDs"
--- 2. Define Patch for 'start_local_watcher' ---
$Patch_LocalWatcher = @"
def start_local_watcher():
if not WATCHDOG_INSTALLED:
print("Error: 'watchdog' is required. Please run: pip install watchdog", file=sys.stderr)
sys.exit(1)
config = load_config()
if not config:
    print("Error: No projects registered. Run 'python Sentinel.py register' first.", file=sys.stderr)
    sys.exit(1)
    
print("Local Watcher scanning for registered projects:")
for proj_id, path in config.items():
    print(f"  - {proj_id}: {path}")

class LocalPatchHandler(FileSystemEventHandler):
    def on_created(self, event):
        if event.is_directory: return
        filepath = event.src_path
        filename = os.path.basename(filepath)
        
        # Check for our new file format: SentScript-PROJECT_ID-*.txt
        if filename.endswith(".txt") and filename.startswith("SentScript-"):
            try:
                # --- FIXED PARSER LOGIC ---
                parts = filename.split('-')
                if len(parts) < 4: # e.g., SentScript-proj-b6cc-Description.txt
                    print(f"\n[Local Watcher] Invalid filename format (not enough parts): {filename}. Ignoring.", flush=True)
                    return
                project_id = f"{parts[1]}-{parts[2]}" # Re-combine 'proj' and 'b6cc'
                # --- END FIXED LOGIC ---
                
                config = load_config()
                
                if project_id not in config:
                    print(f"\n[Local Watcher] Detected file for unknown project ID: {project_id}. Ignoring.", flush=True)
                    return
                    
                target_project_path = config[project_id]
                print(f"\n\n--- [Local Watcher] New Patch File Detected: {filename} ---", flush=True)
                print(f"--- Target Project: {project_id} ({target_project_path}) ---", flush=True)

                with open(filepath, 'r', encoding='utf-8') as f:
                    script_content = f.read()
                
                if verify_and_run_patch(script_content, filename, target_project_path):
                    print(f"[Local Watcher] Cleaning up '{filename}'...", flush=True)
                    if os.path.exists(filepath):
                        os.remove(filepath)
                else:
                    print(f"[Local Watcher] Patch failed or aborted. Deleting '{filename}'.", flush=True)
                    if os.path.exists(filepath):
                        os.remove(filepath)
            except Exception as e:
                print(f"[Local Watcher] Error processing file: {e}. Ignoring.", flush=True)

# Watcher must now watch all registered directories
observer = Observer()
for path in config.values():
    if os.path.exists(path):
        observer.schedule(LocalPatchHandler(), path, recursive=False)
    else:
        print(f"Warning: Path not found for project. Not watching: {path}", file=sys.stderr)

print("==================================================")
print("✅ Sentinel 'Local Watcher' Service Started")
print(f"Watching for new 'SentScript-ID-*.txt' files in all registered project folders.")
print("Press CTRL+C to stop the watcher.")
print("==================================================")

observer.start()
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    observer.stop()
    print("\n[Local Watcher] Service stopped by user.")
observer.join()

"@
--- 3. Define Patch for 'start_drive_watcher' ---
$Patch_DriveWatcher = @"
def start_drive_watcher():
if not GOOGLE_API_INSTALLED:
print("Error: Google API libraries are required. Please run: pip install -r requirements.txt", file=sys.stderr)
sys.exit(1)
print("Authenticating with Google Drive...")
try:
    service = get_drive_service()
    print("Authentication successful.")
except Exception as e:
    print(f"Failed to authenticate with Google Drive: {e}", file=sys.stderr)
    sys.exit(1)

print("==================================================")
print("✅ Sentinel 'Google Drive Watcher' Service Started")
print(f"Polling for new 'SentScript-ID-*.txt' files every {POLL_INTERVAL_SECONDS} seconds.")
print("Press CTRL+C to stop the watcher.")
print("==================================================")

processed_file_ids = set()

try:
    while True:
        try:
            # Search for .txt files that start with "SentScript-"
            results = service.files().list(
                q="mimeType='text/plain' and name starts with 'SentScript-'",
                pageSize=10,
                orderBy="createdTime desc",
                fields="files(id, name, createdTime)"
            ).execute()
            
            items = results.get('files', [])

            if not items:
                print(f"[{time.ctime()}] No new .txt files found. Sleeping...", end="\r", flush=True)
            else:
                config = load_config()
                for item in reversed(items):
                    file_id = item['id']
                    filename = item['name']
                    
                    if file_id in processed_file_ids:
                        continue

                    # --- New Multi-Project Logic ---
                    try:
                        # --- FIXED PARSER LOGIC ---
                        parts = filename.split('-')
                        if len(parts) < 3: # e.g., SentScript-proj-Fix.txt
                            print(f"\n[Drive Watcher] Invalid filename format (not enough parts): {filename}. Ignoring.", flush=True)
                            processed_file_ids.add(file_id) # Mark as processed to avoid re-checking
                            continue
                        
                        # Check if ID is simple (e.g., 'proj') or complex ('proj-b6cc')
                        if len(parts) >= 4 and parts[1].startswith("proj"):
                            project_id = f"{parts[1]}-{parts[2]}" # Re-combine 'proj' and 'b6cc'
                        else:
                            project_id = parts[1] # Use simple ID like 'proj'
                        # --- END FIXED LOGIC ---
                    except IndexError:
                        print(f"\n[Drive Watcher] Invalid filename format (no ID): {filename}. Ignoring.", flush=True)
                        processed_file_ids.add(file_id) # Mark as processed to avoid re-checking
                        continue
                        
                    if project_id not in config:
                        print(f"\n[Drive Watcher] Detected file for unknown project ID: {project_id}. Ignoring.", flush=True)
                        processed_file_ids.add(file_id)
                        continue
                    
                    target_project_path = config[project_id]
                    print(f"\n--- [Drive Watcher] New Patch File Detected: {filename} (ID: {file_id}) ---", flush=True)
                    print(f"--- Target Project: {project_id} ({target_project_path}) ---", flush=True)
                    processed_file_ids.add(file_id) # Mark as processed
                    
                    try:
                        # Download the file content
                        request = service.files().get_media(fileId=file_id)
                        file_handle = io.BytesIO()
                        downloader = MediaIoBaseDownload(file_handle, request)
                        done = False
                        while done is False:
                            status, done = downloader.next_chunk()
                        script_content = file_handle.getvalue().decode('utf-8')
                        
                        if verify_and_run_patch(script_content, filename, target_project_path):
                            print(f"[Drive Watcher] Deleting '{filename}' from Google Drive...", flush=True)
                            service.files().delete(fileId=file_id).execute()
                        else:
                            print(f"[Drive Watcher] Patch failed or aborted. Deleting '{filename}' from Drive.", flush=True)
                            service.files().delete(fileId=file_id).execute()

                    except HttpError as e:
                        print(f"[Drive Watcher] Error processing file {filename}: {e}", flush=True)
                    except Exception as e:
                        print(f"[Drive Watcher] A critical error occurred processing {filename}: {e}", flush=True)
                            
        except HttpError as e:
            print(f"\n[Drive Watcher] API Error: {e}. Retrying...", flush=True)
        except Exception as e:
            print(f"\n[Drive Watcher] An unexpected error occurred: {e}", flush=True)
        
        time.sleep(POLL_INTERVAL_SECONDS)
        
except KeyboardInterrupt:
    print("\n[Drive Watcher] Service stopped by user.")

"@
--- 4. Apply Patches ---
Write-Host "--- 1. Applying patch for 'start_local_watcher' ---" -ForegroundColor Yellow
$Patch_LocalWatcher | python $SentinelToolPath patch "Sentinel.py" "start_local_watcher"
if ($LASTEXITCODE -ne 0) {
Write-Error "Sentinel patch command failed for 'start_local_watcher'!"
exit 1
}
Write-Host "--- 2. Applying patch for 'start_drive_watcher' ---" -ForegroundColor Yellow
$Patch_DriveWatcher | python $SentinelToolPath patch "Sentinel.py" "start_drive_watcher"
if ($LASTEXITCODE -ne 0) {
Write-Error "Sentinel patch command failed for 'start_drive_watcher'!"
exit 1
}
--- 5. Commit Changes ---
Write-Host "--- 3. Committing changes to Git ---" -ForegroundColor Yellow
try {
git add .
git commit -m $CommitMessage
Write-Host "SUCCESS: Patched Sentinel.py and committed changes." -ForegroundColor Green
}
catch {
Write-Error "Failed to commit to Git:"
Write-Error $_
exit 1
}
Write-Host "======================================================="
Write-Host "✅ SENTINEL UPGRADE COMPLETE ✅"
Write-Host "Parser logic has been fixed. Please RESTART your watcher."
Write-Host "======================================================="
